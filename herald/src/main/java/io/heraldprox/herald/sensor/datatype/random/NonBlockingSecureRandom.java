//  Copyright 2021 Herald Project Contributors
//  SPDX-License-Identifier: Apache-2.0
//

package io.heraldprox.herald.sensor.datatype.random;

import java.security.MessageDigest;
import java.util.Arrays;
import java.util.Date;
import java.util.Random;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;

import io.heraldprox.herald.sensor.data.ConcreteSensorLogger;
import io.heraldprox.herald.sensor.data.SensorLogger;
import io.heraldprox.herald.sensor.datatype.Data;
import io.heraldprox.herald.sensor.datatype.Int32;
import io.heraldprox.herald.sensor.datatype.Int64;
import io.heraldprox.herald.sensor.datatype.TimeInterval;
import io.heraldprox.herald.sensor.payload.simple.F;

/**
 * Non-blocking cryptographically secure random source based on a combination of SecureRandom
 * and reliable entropy sources. SecureRandom is blocking when it is used on an idle device
 * as entropy is exhausted. The lack of system activities mean entropy is not replenished at
 * a required rate, thus causing other subsystems that rely on this mechanism for random data
 * to also block, e.g. BLE MAC address generation, and halting the app until the device is
 * active again. This solution uses SecureRandom to generate the initial internal state, the
 * assumption is that it will not block as the app can only be started on an active device.
 * Random data is derived from this internal state via a cryptographic hash function (SHA256)
 * which is known to offer uniformly distributed hash bits. Internal state updates are also
 * derived from a mixture of the previous state and truly random entropy data, thus making it
 * cryptographically challenging to predict the internal state and initial seed. Finally, the
 * internal state is replaced at random intervals at a time selected by SecureRandom and data
 * generated by SecureRandom. This is an optional background task that occurs at a slow rate,
 * thus unlikely to cause blocking across the system, and also blocking will simply delay
 * internal state replacement which is non-critical given the other mechanisms in place.
 *
 * Note: Logging has been disabled by commenting to avoid information leakage, only fault
 * messages are retained.
 */
public class NonBlockingSecureRandom extends RandomSource {
    private final static SensorLogger logger = new ConcreteSensorLogger("Sensor", "Datatype.NonBlockingSecureRandom");
    // Reseed interval parameters
    private final TimeInterval minimumReseedInterval;
    private final TimeInterval maximumReseedInterval;
    // Internal state management
    private final RandomSource seedRandomSource;
    private final AtomicReference<Data> state = new AtomicReference<>(new Data());
    private final AtomicBoolean reseedInProgress = new AtomicBoolean(false);
    private long nextReseedTimestamp = 0;
    // Entropy sources
    private long addEntropyLastCalledAt = System.nanoTime();
    private long nextBytesLastCalledAt = System.nanoTime();


    /**
     * Non-blocking cryptographically secure random source based on a combination of SecureRandom
     * and reliable entropy sources. SecureRandom is blocking when it is used on an idle device
     * as entropy is exhausted. The lack of system activities mean entropy is not replenished at
     * a required rate, thus causing other subsystems that rely on this mechanism for random data
     * to also block, e.g. BLE MAC address generation, and halting the app until the device is
     * active again. This solution uses SecureRandom to generate the initial internal state, the
     * assumption is that it will not block as the app can only be started on an active device.
     * Random data is derived from this internal state via a cryptographic hash function (SHA256)
     * which is known to offer uniformly distributed hash bits. Internal state updates are also
     * derived from a mixture of the previous state and truly random entropy data, thus making it
     * cryptographically challenging to predict the internal state and initial seed. Finally, the
     * internal state is replaced at random intervals at a time selected by SecureRandom and data
     * generated by SecureRandom. This is an optional background task that occurs at a slow rate,
     * thus unlikely to cause blocking across the system, and also blocking will simply delay
     * internal state replacement which is non-critical given the other mechanisms in place.
     *
     * @param minimumReseedInterval Minimum time between internal state replacement, suggest
     *                              6+ hours to ensure entropy is not exhausted on an idle device.
     *                              Previous experiments have shown blocking occurs after 4 - 7.5
     *                              hours of using SecureRandom, which is equivalent to about
     *                              16 - 30 requests (once every 15 minutes). Setting it to 6+
     *                              hours means the solution should not block unless the device
     *                              is left idle for about 100 hours.
     * @param maximumReseedInterval Maximum time between internal state replacement, suggest 24
     *                              hours to ensure reseeding occurs at a rate that limits the
     *                              number of observations available to the attacker to 24 * 4
     *                              = 96 pseudo device addresses. It will be cryptographically
     *                              challenging to link these 96 addresses that are separated
     *                              by a combination of SHA256 and truly random entropy data.
     */
    public NonBlockingSecureRandom(final TimeInterval minimumReseedInterval, final TimeInterval maximumReseedInterval) {
        // Using an instance of SecureRandom seeded according to NIST SP800-90A
        // recommendations. There is a small risk that this will block on app
        // start but it is unlikely for an active device to be out of entropy.
        // The blocking problem with SecureRandom has previously been observed
        // on app start only when the phone was recently booted, and mostly when
        // the app has been running in the background and phone is idle overnight.
        this.seedRandomSource = new BlockingSecureRandomNIST();
        // Initialise internal state. This will be replaced at random intervals
        // but at a slow rate (e.g. 6 - 24 hours) to avoid exhausting system
        // entropy which is required by other subsystems, such as generation of
        // BLE MAC addresses.
        this.minimumReseedInterval = minimumReseedInterval;
        this.maximumReseedInterval = maximumReseedInterval;
        reseed(null);
    }

    /**
     * Non-blocking cryptographically secure random source based on recommended reseeding interval
     * parameters for pseudo device address generation. Internal state is fully replaced by
     * SecureRandom once every 6 to 24 hours to avoid exhausting entropy on idle systems.
     */
    public NonBlockingSecureRandom() {
        this(TimeInterval.hours(6), TimeInterval.day);
    }

    /**
     * Using BLE MAC address of target device and elapsed time between detection as entropy source.
     * @param value BLE MAC address of target device
     */
    @Override
    public synchronized void addEntropy(String value) {
        super.addEntropy(value);
        super.addEntropy(addEntropyLastCalledAt ^ System.nanoTime());
        addEntropyLastCalledAt = System.nanoTime();
    }

    /**
     * Replace internal state as soon as possible with random data derived from
     * SecureRandom via SHA256 cryptographic hash.
     */
    private synchronized void reseed(final Data seed) {
        // Set state to supplied seed and attempt to reseed afterwards
        if (seed != null && seed.value.length > 0) {
            state.set(seed);
        }
        // Ignore reseed requests if not reach next reseed timestamp
        if (System.currentTimeMillis() < nextReseedTimestamp) {
            //logger.debug("reseed is not due yet");
            return;
        }
        // Ignore reseed requests if one is already in progress or blocking
        if (!reseedInProgress.compareAndSet(false, true)) {
            //logger.debug("reseed already in progress");
            return;
        }
        //logger.debug("reseed requested");
        // Start background thread to reseed, this may block indefinitely
        // until the phone is active, which should happen at least a few
        // times a day if the user is carrying the device.
        final Runnable runnable = new Runnable() {
            @Override
            public void run() {
                // Generate new seed
                final Data randomData = new Data(new byte[512]);
                final long startTime = System.currentTimeMillis();
                seedRandomSource.nextBytes(randomData.value);
                final Data seed = hash(randomData);
                // Generate next reseed time
                final long randomLong = seedRandomSource.nextLong();
                final long endTime = System.currentTimeMillis();
                if (seed != null) {
                    state.set(seed);
                    final long intervalRange = maximumReseedInterval.millis() - minimumReseedInterval.millis();
                    final long intervalSelected = (intervalRange <= 0 ? 0 : Math.abs(randomLong) % intervalRange);
                    nextReseedTimestamp = System.currentTimeMillis() + minimumReseedInterval.millis() + intervalSelected;
                    //logger.debug("reseed successful (elapsed={}ms,nextInterval={}ms)", (endTime - startTime), intervalSelected);
                } else {
                    logger.fault("reseed failed (elapsed={}ms)", (endTime - startTime));
                }
                reseedInProgress.set(false);
            }
        };
        new Thread(runnable).start();
    }

    @Override
    public synchronized void nextBytes(final byte[] bytes) {
        // Requirement 1 : Truly random seed
        // CSPRNG must be initialised with a truly random seed to be cryptographically secure.
        // SecureRandom achieves this by using entropy collected from system events. This causes
        // blocking on idle systems due to lack of entropy. The same is achieved here by using
        // knowledge of the target application to derive truly random data from real-world events.
        // - 1A. Entropy from elapsed time between calls which is determined by state of recently
        //       encountered devices, and the proximity and state of devices in the user environment.
        //       Even if the device is in isolation, the call time is still unpredictable at nano
        //       time scale as the source time keeper is based on an infinite CPU loop that samples
        //       current time at millisecond scale, quantized to 500ms scale.
        addEntropy(System.nanoTime() ^ nextBytesLastCalledAt);
        nextBytesLastCalledAt = System.nanoTime();
        // - 1B. Entropy from external sources that are likely to have been derived from disparate
        //       SecureRandom instances. Using the sequence of detected BLE MAC addressed and time
        //       of detection as entropy material. This has been handled by addEntropy().

        // Requirement 2 : Uniformly distributed PRNG
        // CSPRNG must deliver uniformly distributed random values and a long period length, such
        // that knowledge of prior values offer negligible or no benefit in predicting future values.
        // - 2A. SHA256 cryptographic hash function is efficient and non-blocking. The output bits
        //       follow a uniform distribution and its characteristics are well understood. Applying
        //       SHA256 to current state and entropy data to generate the new state. Entropy data
        //       prevents future states from being predicted from current state if internal state
        //       has been compromised. The internal state is replaced by SecureRandom data at regular
        //       intervals to further prevent compromise.
        final Data currentState = state.get();
        final Data newStateSourceMaterial = new Data();
        //       source material = current state + external entropy
        newStateSourceMaterial.append(currentState);
        useEntropy(newStateSourceMaterial);
        final Data newState = hash(newStateSourceMaterial);
        //       replace internal state with new state, and attempt to reseed if required
        reseed(newState);
        // - 2B. Using a combination of current and new states to derive an ephemeral random seed
        //       for generating the actual random data. The ephemeral seed is cryptographically
        //       separated from the underlying internal state via SHA256 and also an XOR function.
        //       The transformation "ephemeralSeed = sha256(xor(currentState, newState))" means
        //       the identification of current or new state will be cryptographically challenging
        //       given the ephemeral seed.
        final Data ephemeralRandomSeed = hash(xor(currentState, newState));
        // - 2C. Uniformly distributed random data is generated by recursive application of SHA256
        //       to hashes derived from the ephemeral random seed. SHA256 hashes are known to offer
        //       uniformly distributed bits, thus offering a sound basis as a pseudo random number
        //       generator. This recursive process is non-blocking but computationally expensive
        //       but the solution is primarily designed for generation of pseudo device addresses
        //       which is only 6 bytes long derived from truncation of 8 bytes of random data.
        Data randomByteBlock = hash(ephemeralRandomSeed);
        for (int i=0; i<bytes.length; i++) {
            // Taking the first byte from the hash as random data
            bytes[i] = randomByteBlock.value[0];
            // Hashing the remaining bytes mixed with part of the ephemeral random seed to generate
            // the next block
            randomByteBlock = hash(xor(ephemeralRandomSeed.subdata(1), randomByteBlock.subdata(1)));
        }
    }

    /**
     * XOR function : Compute left xor right, assumes left and right are the same length
     * If the left and right data are of different lengths, the function will return
     * xor(left, right) up to minimum length.
     */
    public final static Data xor(final Data left, final Data right) {
        if (left.value.length != right.value.length) {
            logger.fault("XOR being applied to data of different lengths (left={},right={})", left.value.length, right.value.length);
        }
        final byte[] leftByteArray = left.value;
        final byte[] rightByteArray = right.value;
        final byte[] resultByteArray = new byte[Math.min(leftByteArray.length, rightByteArray.length)];
        for (int i=resultByteArray.length; i-->0;) {
            resultByteArray[i] = (byte) (leftByteArray[i] ^ rightByteArray[i]);
        }
        return new Data(resultByteArray);
    }

}
